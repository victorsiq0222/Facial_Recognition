# -*- coding: utf-8 -*-
"""Reco_Facial.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NMqyD1Q8fBF-y9yjyi9PUXJFhNtBT-pT

# Código para reconhecimento Facial e aplicações de visão computacional
"""

!wget http://dlib.net/files/shape_predictor_68_face_landmarks.dat.bz2
!wget http://dlib.net/files/dlib_face_recognition_resnet_model_v1.dat.bz2

!bunzip2 shape_predictor_68_face_landmarks.dat.bz2
!bunzip2 dlib_face_recognition_resnet_model_v1.dat.bz2

import cv2
import dlib
from google.colab.patches import cv2_imshow
from scipy.spatial import distance as dist
from deepface import DeepFace

img = cv2.imread("chat_img.png")

import os
print(os.listdir())  # Lista os arquivos na pasta atual

img

img.shape

# instânciando o dector de rostos
detector = dlib.get_frontal_face_detector()
# convertendo imagem em uma resolução mais baixa ( toda cinza )
img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
# new_shape = (1000,1000,3)
# img_gray.resize(new_shape)
# pegando os vetores das loc dos rostos
faces = detector(img_gray)
faces

faces[0].top()

try:

  for i , rosto in enumerate(faces):
    x1 = rosto.left()
    y1 = rosto.top()
    x2 = rosto.right()
    y2 = rosto.bottom()

    cv2.rectangle(img, (x1,y1),(x2,y2),(0, 255, 0), 2)
    cv2.putText(img, f"Rosto {i+1}", (x1, y1 - 10),
                  cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)

except Exception as e:
    print(f"erro:{e} no rosto de número {i}")


cv2_imshow(img)

"""- Comparando duas imagens por distância Eucliadiana usando o DeepFace para verificarmos se é ou não a mesma pessoa

"""

pessoa1 = cv2.imread("/content/pessoa1.png")
pessoa2 = cv2.imread("/content/pessoa2.png")

pessoa1.shape # tamanho da imagem 1

# img_rgb1 = cv2.cvtColor(pessoa1, cv2.COLOR_BGR2RGB)
# img_rgb2 = cv2.cvtColor(pessoa2, cv2.COLOR_BGR2RGB)

def recon_facial(img1,img2):
  emb1 = DeepFace.represent(img_path = pessoa1, model_name = 'Facenet')[0]["embedding"]
  emb2 = DeepFace.represent(img_path = pessoa2, model_name = 'Facenet')[0]["embedding"]

  distance = dist.euclidean(emb1, emb2)

  if distance < 12:
    print(f"distância eucliadiana é {distance}, logo são a mesma pessoa")
  else:
    print(f"distância eucliadiana é {distance}, logo não é a mesma pessoa")

recon_facial(pessoa1,pessoa2)

"""- Vendo se na imagem com várias pessoas, conseguimos reconhecer uma pessoa específica na foto"""

detected_faces = DeepFace.extract_faces(img_path=img, enforce_detection=False)

detected_faces[0]["face"] # é uma lista com dicionários de todas as características da face de cada pessoa

# detected_faces = DeepFace.extract_faces(img_path=img, enforce_detection=False)

# emb1 = DeepFace.represent(img_path = pessoa1, model_name = 'Facenet')[0]["embedding"]

# dict_distance = {}
# # Comparar cada rosto da imagem com a pessoa de referência
# for i, face in enumerate(detected_faces):
#     face_crop = face["face"]  # o crop do rosto (em RGB)

#     emb_pessoa = DeepFace.represent(img_path=face_crop, model_name="Facenet",enforce_detection=False)[0]["embedding"]

#     distance = dist.euclidean(emb_pessoa,emb1)

#     dict_distance[f"rosto{i}"] = distance

# print(dict_distance)

# Carregar imagens
img_chat = "chat_img.png"

img =cv2.imread(img_chat)
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)


pessoa2 = "pessoa2.png"

# Extrair todos os rostos da imagem principal
detected_faces = DeepFace.extract_faces(img_path=img_chat, enforce_detection=False)

# Extrair embedding da pessoa de referência
emb1 = DeepFace.represent(img_path=pessoa1, model_name='Facenet')[0]["embedding"]

# Dicionário para guardar distâncias e posições
dict_distance = {}
dict_regions = {}

# Loop para calcular distância para cada rosto
for i, face in enumerate(detected_faces):
    face_crop = face["face"]
    region = face["facial_area"]

    emb_pessoa = DeepFace.represent(img_path=face_crop,model_name="Facenet",enforce_detection=False)[0]["embedding"]

    dist_euc = dist.euclidean(emb_pessoa, emb1)

    chave = f"rosto{i+1}"
    dict_distance[chave] = dist_euc
    dict_regions[chave] = region

# Encontrar o rosto mais próximo
chave_menor = min(dict_distance, key=dict_distance.get)
valor_menor = dict_distance[chave_menor]

# Desenhar todos os rostos e destacar o mais próximo
for chave, region in dict_regions.items():
    x, y, w, h = region["x"], region["y"], region["w"], region["h"]

    if chave == chave_menor:
        cor = (0, 255, 0)  # verde: rosto mais parecido
        label = f"{chave} (MATCH!)"
    else:
        cor = (0, 0, 255)  # vermelho: outros
        label = chave

    cv2.rectangle(img, (x, y), (x + w, y + h), cor, 2)
    cv2.putText(img, label, (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.6, cor, 2)

# Mostrar resultado
cv2_imshow(img)

# Resultado final
print(f"✅ O rosto mais provável é o: {chave_menor}, com distância: {valor_menor:.4f}")